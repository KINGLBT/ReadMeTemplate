### 关于目前iOS-QQ安全中心代码的一些弊端

  目前iOS-QQ安全中心代码经过了多次的版本协议调整，几位开发人员的参与，从开头的QQ手机令牌到现在的版本，代码基本没有过重构，
老的一些模块逻辑不清晰，代码重复率高，程序性能不好且不稳定。具体表现为：

  * 1) 网络模块性能
    
    由于历史原因，目前网络的处理采用单一子线程同步阻塞处理模式，见下图：

    
    这个模型的最大缺点在于线性的叠加了所有网络包的等待收包时间，假如同一时间发送4个请求，那么第4个请求的时间基本就是总4个
时间的线性叠加，更糟的是，假如前面的任务1，任务2的超时，任务3，任务4也会跟着等待。v2.1版本开始暂时对这部分模块在现有代码
的基础上做了一些优化，部分请求再额外单独开启子线程来处理，但是还是基于同步阻塞模式。

  * 2) 消息数据存储
    
    下面是各个版本的消息数据库结构和数据迁移
    
    
    
        //12-8-1增加字段(detail TEXT, site TEXT, ip TEXT, money INTEGER)
        //12-9－6 site,money,detail删除
        //12-8-17增加字段(countryId INTEGER, provId INTEGER, cityId INTEGER)
        //12-8-20增加字段(typeC INTEGER)
        //12-9－6增加字段(msgTable TEXT)
        //13-3－5增加字段(actionBtnText TEXT, feedbackType TEXT, feedbackTarget TEXT, feedbackBtnText TEXT, textBefore TEXT, textAfter TEXT)
        [self createDBTable:kLoginMsgTableName];// 创建新表
        [self copyAndDropTable:kOldLoginMsgTableName toTable:kLoginMsgTableName];// 拷贝老表
        [self copyAndDropTable2:kOldLoginMsgTableName2 toTable:kLoginMsgTableName];// 拷贝老表

    从v1.7版本到最近的v2.1版本，数据库结构前前后后改了6次。

  * 3) 底层协议模块不清晰，逻辑交互复杂，上层代码重复率高

    从开头的QQ手机令牌，经过几次的产品需求调整，模块之间划分越来越多，模块之间交叉的地方也越来越多，重复代码率相当高，
以获取绑定QQ号为例，假如软件一启动需要拉取绑定的QQ号，这存在几种情况，当前在哪个界面，当前绑定有否，当前初始化种子是否
，之类的，然后就会出现下面的交互图：
    
    
    
    实线表示为请求，虚线表示消息广播，图中UI层对于处理初始化失败，拉取数据失败以及过程提示基本都是重复代码，广播消息没有
定义完善，上层也不知道是哪一步出错，或者是因为网络原因出错。实际上有些逻辑交互可能会很复杂，还涉及到了wtloginSDK的东西，
接口没有统一起来，造成上层的调用非常麻烦，通常的一个请求，可能需要实现n多回调才能完成逻辑交互。

  * 4) 部分数据存储，底层缓存数据，上层UI控件统一化
    
    这里需要优化的地方有点杂小，比如帐号列表数据目前是序列化到磁盘，但是这当中包括了头像数据，头像数据应当不应该和帐号
信息一起序列化下来，而是单独保存到文件，因为有两点：1.头像数据比较大，跟随帐号信息序列化到文件效率比较低；2.帐号删除的
情况下，头像也会跟着被删除，那么在第一次的登录界面，用户再输入相对于的QQ号就再看不到他之前绑定过的QQ号头像了。还比如目前
本地缓存帐号和获取绑定QQ帐号是分开缓存的，上层在判断当前帐号信息的时候，统一的很多重复代码来区别当前的帐号数据源。

### 后续重构的一些思路

  代码重构的本质是要解决现有问题，并且再后续扩展更加容易，最主要的是完善程序的稳定性，以及让开发人员能够了解程序在每一个时刻
的生命状态。
  后续会针对上述的问题逐一优化，因为考虑到从v2.3版本开始，版本迭代速度会变快，所以会分开两条线，一条线在保证新的迭代功能
的添加，版本按时上线；另一条线在v2.2的基础上做修改，逐步合入到最新的代码上去，整个工程的重构时间，在不影响新版本开发进度的
情况下，耗时大概一个月，关于上述问题的一些解决办法：

  * 1) 网络模块重写(包括一些其它基础模块的抽离：异步并发调用，基础接口函数等)(已完成，但未替换)
    
    
    
    上述的网络组件表现为：
    * a) 还是采用唯一子线程处理网络收发包；
    * b) 网络收包取消同步阻塞模式，采用基于异步的消息模式，提高效率；
    * c) 动态设置同一时间网络请求的并发数；
    * d) 上层赋予每个http请求单独的超时时间，赋予每个http请求的标识符和序列号，通过这两个参数来定制去重复http请求，上层还根据这两个参数来取消http请求；
    
    通过这个网络模型能够有效的提高目前网络模块的效率和性能，但又不会的过高的加大cpu负载以及浪费流量。

  * 2) 消息数据存储(v2.2版本已重构完成)
  
    v2.2版本关于数据存储的处理
    
    
    
    v2.2版本为了避免后续协议字段的添加和修改，把服务器下发的json字符串作为一整个信息存储下来，读取的时候再实时解析。
    这么做有两个好处：
      * a) 处理版本兼容变得很简单；
      * b) 协议数据不会因为数据库的原因丢失，旧版本升级上来，还可以读取因为旧版本无法处理的协议内容；
  
  * 3) 底层协议交互部分，数据缓存部分接口全部统一起来
    
    

    上图表示AQCenterSDK为整个安全中心App的核心入口，所有的协议交互，数据都在这里，上层只通过AQCenter做任何的数据交互，
为了灵活性，对于交互方式，AQCenter的异步请求会取消消息广播的模式，采用block回调的方式，除此之外，AQCenter的所有
异步请求接口模型实现一对多的回调，回调优先级的排序，并且由外层自定义优先级，去重请求以及后续分发截断。由于AQCenter管理
所有的缓存数据(除去上层UI部分)，因此需要内部做好多线程并发的数据安全处理，且对上层透明。

  * 4) 统一App所有的自定义控件，字体大小，颜色以及一些交互方式
  
    v2.2更改了一部分控件未统一，字体大小不一样的问题，为了体现App的统一性，以及后续能够切换UI，对一些共性的东西都需要
抽离，比如以下这几个界面的字体和颜色：

    
    再比如下面这几个界面的样式：
    
    
    又再如这几个交互方式：
    
    
    希望在产品层面可以统一起来。










